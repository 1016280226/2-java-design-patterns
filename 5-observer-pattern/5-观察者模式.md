# 笔记六 观察者模式（Observer Pattern）

## 1. 什么是观察者模式 ？

### <font color=#e96900>观察者模式 （Observer Pattern）:</font>

- 在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。 
- 属于`行为模式`
- 例如：发布订阅模式、 分布式注册中心机制

## 2. 为什么使用观察者模式？

### 一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。

## 3. 应用场景

> - Zookeeper事件通知节点
> - 消息订阅通知
> - 安卓开发事件注册
> - 分布式配置中心

## 4.  原理

如下图结构所示：

<center>
    <img src="./statics/images/desgin-mode/observer_mode.png" style="zoom:150%;" /><br>
	<font size=4px><b>观察者模式UML模型</b></font>
</center>


`观察者模式`主要包含四个角色：

- #### **`抽象主题角色（Subject）`**:  接口或抽象类；
    - 它把所有对观察者对象的**引用保存在一个集合中**，每个主题都**可以有任意数量的观察者**。
    - 抽象主题提供一个接口，可以**增加**和**删除观察者角色**。
    - 一般用一个**抽象类**和**接口**来实现。

- #### **`抽象观察者角色 (Observer)`**:
    - 为所有的具体观察者定义一个接口，在得到主题通知时更新自己。

- #### **`具体主题角色（Concrete Subject）`**:
    - 在集体主题的内部状态改变时，所有注册过的观察者发出通知。
    
- #### **`具体观察者角色（Observer Observer）`**:
    - 实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。

## 5. 观察者模式-案例1：订阅发送消息

### <font color=#e96900>1. 抽象观察者角色 (Observer)</font>

```java
package com.message.observer;

/**
 * description: 抽象观察者
 * date: 2020/9/16 1:14
 * author: Calvin
 * version: 1.0
 */
public interface MessageObserver {

    /**
     * 更新消息内容
     *
     * @param message 消息内容
     */
    void update(String message);
}

```

### <font color=#e96900>2. 抽象主题角色（Subject）</font>

```java
package com.message.observable;


import com.message.observer.MessageObserver;

/**
 * description: 抽象被观察者 （抽象主题角色）
 * date: 2020/9/16 1:11
 * author: Calvin
 * version: 1.0
 */
public interface MessageObservable {

    /**
     * 添加观察者
     *
     * @param messageObserver 观察者
     */
    void addObserver(MessageObserver messageObserver);

    /**
     * 移除观察者
     *
     * @param messageObserver 观察者
     */
    void removeObserver(MessageObserver messageObserver);

    /**
     * 发送消息通知给所有观察者
     *
     * @param message 消息
     */
    void notifyObservers(String message);

}
```

### <font color=#e96900>3. 具体主题角色（Concrete Subject）</font>

- 短信 SMS
- 微信公众号 WechantMp

```java
package com.message.observer;

/**
 * description: 微信公众号观察者（具体观察者）
 * date: 2020/9/16 1:26
 * author: Calvin
 * version: 1.0
 */
public class SmsObserver implements MessageObserver {

    /**
     * 订阅者用户名称
     */
    private String name;

    /**
     * 发送内容
     */
    private String message;


    public SmsObserver(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        this.message = message;
        println();
    }

    private void println() {
        System.out.println("【" + name + "】" + "收到短息消息:" + message);
    }

}
```
```java
package com.message.observer;

import com.message.observable.MessageObservable;
import com.message.observable.MessageObservableImpl;

/**
 * description: 微信公众号观察者（具体观察者）
 * date: 2020/9/16 1:26
 * author: Calvin
 * version: 1.0
 */
public class WechatMpObserver implements MessageObserver {

    /**
     * 订阅者用户名称
     */
    private String name;

    /**
     * 发送内容
     */
    private String message;


    public WechatMpObserver(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        this.message = message;
        println();
    }

    private void println() {
        System.out.println("【" + name + "】" + "收到微信公众号推送消息:" + message);
    }
   
}
```

### 4. 编写测试

```java
public static void main(String[] args) {
         // 1. 创建具体主题
         MessageObservable messageObservable = new MessageObservableImpl();
         // 2. 添加订阅者
         messageObservable.addObserver(new SmsObserver("Calvin"));
         messageObservable.addObserver(new WechatMpObserver("Calvin"));
         // 3.组装消息内容
         messageObservable.notifyObservers("这是观察者模式");
}
```

### 5. 运行结果

```verilog
【Calvin】收到短息消息:这是观察者模式
【Calvin】收到微信公众号推送消息:这是观察者模式
```

## 6. 观察者模式-案例2：通过JDK, 实现订阅发送消息
